# [11주차] Java

Assign: 신종웅
Tutor: No
속성: 2022년 5월 17일 오후 1:57

<aside>
✅ **영상 시청 후 영상 밑의 설명을 보며 자바라는 언어가 어떤 언어인지 훑고 실습 하는 형식으로 진행 하였습니다.**

</aside>

### 1. 자바 시작하기

- 자바란?
    - 1995년에 썬 마이크로시스템즈에서 발표한 **객체 지향 언어**이다.
    - 현재는 오라클에 인수 되어 오라클의 자바로 불림
    - 자바의 특징
        - 타 언어에 비해 배우기가 쉽다.
        - 플랫폼에 독립적이다.(`Java Virtual Machine`)
        - 객체지향 프로그래밍이다.
        - Garbage Collector로 사용되지 않는 메모리를 자동으로 정리해 준다.
- 자바에서 주석문
    - 주석이란? - 프로그램의 코드와 실행에는 영향을 주지 않는 문장
    - 구현 주석
        - 행 단위 주석(`//`를 해주면 해당 행이 주석처리 된다.)
        - 블럭 단위 주석(`/* 주석내용 */`)
    - 문서화 주석
        - `/** 문서에 포함될 내용 작성 **`
    
    - 문제
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%201.png)
    

### 2. 변수와 계산

- 변수
    - **변수란? - 값을 저장할 수 있는 메모리 공간을 뜻한다.**
    
    ### **변수의 선언**
    
    - 타입 변수이름;
        - int count; ( 정수 값을 담을 수 있는 count라는 이름의 변수를 선언)
        - double average; ( 실수 값을 담을 수 있는 average 라는 변수를 선언)
    - 명명규칙.
        - 변수의 이름을 정할 때 자바 언어에서 정해놓은 규칙
    - **식별자**는 클래스, 메소드, 변수 등 다양한 대상에 대해 이름이 붙여지는 경우. 그 이름을 뜻 함
    
    ### 자바에서 **식별자 명명 규칙**
    
    - 하나 이상의 글자로 이루어져야 함
    - 첫 번째 글자는 문자 이거나 `$`, `_`이어야 함
    - 두번재 이후의 글자는 숫자, 문자, `$`, `_`이어야 함
    - `$`, `_` 이외의 특수문자 사용 불가능
    - 길이 제한이 없음
    - 키워드는 식별자로 사용할 수 없음
    - 상수 값을 표현하는 단어 `true`, `false`, `null`은 식별자로 사용할 수 없음
    
    ### **변수 명명 관례**
    
    - 첫 번째 문자가 소문자인 명사로 정함
    - 여러 단어로 구성된 이름의 경우 두번째 단어부터 첫글자를 대문자로 함
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%202.png)
    
    - camelCase로 작성 하는 것이 옳은 방법이다.
    
    ### 문제
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%203.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%204.png)
    
- 상수
    - **상수란? - 수식에서 변하지 않는 값을 의미한다.**
    - 타 언어에선 const, final 등의 키워드를 사용한다.
    - 자바에선 상수의 선언을 final로 한다.
        - 선언 예시 - `final int NUMBER;`
    - 상수는 값을 담을 수 있는 기회가 단 한 번만 허락 됩니다.
    
    ### **상수 명명 관례**
    
    - 대문자로만 구성된 명사로 정함
    - 여러 단어로 구성된 이름의 경우 단어 사이에 '_'을 써서 구분함.
    
    ### **상수를 사용해야 하는 경우**
    
    - 값이 변하면 위험한 경우에 상수를 사용
    - 값만 봤을때 무엇을 의미하는지 쉽게 파악할 수 없는 값에도 값 자체를 사용하기 보다는 상수를 사용
    
    ### 문제
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%205.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%206.png)
    
- 기본형
    - **기본형 타입은 가장 기본이 되는 데이터 타입으로써 정수형, 실수형, 문자형, 불린형등을 의미한다.**
    - 기본형 사용 방법 예시
        - boolean isFun = true;
        - char c ='f';
        - int x = 59;
        - long big = 3456789L; (long은 값을 적을때는 뒤에 소문자 l이나 대문자 L을 적어야 합니다.)
        - float f = 32.5f (float에 값을 대입할 때는 실수 뒤에 소문자 f나 대문자 F를 붙여야 합니다.)
        - double d = 23.34;
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%207.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%208.png)
    
- 기본형 타입 변환
    - **형변환이란? - 변수 또는 리터럴 타입을 다른 타입으로 변환 하는 것을 뜻한다.**
    - 묵시적 형 변환
        - 크기가 작은 타입을 크기가 더 큰 타입으로 바꿀 때 묵시적으로 형을 바꿔준다.
        
        ```java
        int x = 50000;
        long y = x; // 묵시적 형 변환
        ```
        
    - 명시적 형 변환
        - 크기가 더 큰 타입을 작은 타입으로 바꿀 때엔 명시적으로 변환 해주어야 한다.
        
        ```java
        long x = 50000;
        //int y = x;  (이렇게 묵시적으로 수행하면 컴파일러는 오류를 발생 시킨다.) 
        int y = (int) x;  //(반드시 (타입) 으로 명시적으로 형을 바꾸어 주어야 한다.)
        ```
        
    
    ### 문제 1
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%209.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2010.png)
    
    ### 문제 2
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2011.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2012.png)
    
- 산술 연산자
    - 부호를 결정하는 부호 연산자 (+, -)
    - 산술 연산을 할 수 있는 산술 연산자 (+, -, /, *, %)
    - 1씩 증가하거나 감소 시키는 증감 연산자 (++, —)
    - 피 연산자가 1개인 연산자는 단항 연산자 (부호 연산자와 증감 연산자는 단항 연산자이다)
    
    ```java
    //부호 연산자 
    int i1 = -5;
    int i2 = +i1;
    int i3 = -i1;
    
    //증감 연산자 
    int i4 = ++i3;
    int i5 = i3++;
    int i6 = --i3;
    int i7 = i3--;
    
    //피연산자 하나로 연산 할 수 없는 연산자 이항 연산자
    int i = 5;
    int j = 2;
    
    //2개의 변수를 이용한 산술 연산
    System.out.println(i +  j);
    System.out.println(i -  j);
    System.out.println(i *  j);
    System.out.println(i /  j);  
    System.out.println(i %  j);
    ```
    
    ### 문제 1
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2013.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2014.png)
    
- 비교 연산자
    - `==`, `≠` ,`<`. `>`, `≤`, `≥`는 모두 비교 연산자로 사용된다.
    - 비교 연산자의 결과는 boolean이다.
    
    ```jsx
    int i = 10; // = 대입연산자 
    int j = 10;    
    
    // i 와 j 가 같은지 비교 하는 비교 연산자           
    System.out.println(i == j ) 
    System.out.println(i == j ) 
    System.out.println(i != j );
    System.out.println(i < j);
    System.out.println( i <= j);
    System.out.println(i > j);
    System.out.println(i >= j);
    ```
    
    ### 문제 1
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2015.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2016.png)
    
- 연산자 우선 순위
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2017.png)
    
    간단한 표로 확인합시다
    

### 3. 제어문

- if 조건문
    - **조건식의 연산 결과에 따라 블록 내부 문장의 실행 여부를 결정 할 수 있다.**
    - if문, if~else문, if~else if~else문이 있다.
        - 처음 if문의 조건식의 조건문이 true일 경우 처음 if문의 블록이 실행되고, false인 경우 다음 조건식의 결과에 따라 실행 블록이 달라진다.
    
    ```jsx
    if(조건식){
        실행문;
        실행문;
    }else if(조건식){
        실행문;
    }else{
        실행문;
    }
    ```
    
    ### 문제 1
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2018.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2019.png)
    
    ### 문제 2
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2020.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2021.png)
    
- 논리 연산자
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2022.png)
    
    - 논리곱 (&&, &) - 피연산자가 모두 true일 경우에만 연산 결과가 true 이다.
    - 논리합 (||,|) - 피연산자 중 하나만 true이면 연산 결과는 true 이다.
    - 베타적 논리합 (^) - 피연산자가 서로 다른 값일 경우만 연산 결과가 true 이다.
    - 논리 부정 (!) - 피연산자의 논리 값을 바꾼다. true는 false로 false는 true로 바꾼다.
    
    ### 문제1
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2023.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2024.png)
    
    ### 문제2
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2025.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2026.png)
    
- 삼항 연산자
    - 여러 줄의 조건 식을 하나의 줄로 만들 수 있는 연산자이다.
    - 조건식 ? 피연산자1 : 피연산자2
        - 조건식의 연산 결과가 true이면, 결과는 피연산자 1이고, 조건식의 연산 결과가 false이면 결과는 피연산자 2이다.
        
        ```java
        int b1 = (5>4) ? 50 : 40; //조건식이 true이므로 b1은 50이 된다.
        
        int b2 = 0;
        if(5 > 4){
            b2 = 50;
        }else{
            b2 = 40;
        } //위 삼항 연산자와 같은 의미를 가짐
        ```
        
    
    ### 문제
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2027.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2028.png)
    
- switch문
    - **switch문은 어떤 변수의 값에 따라서 문장을 실행 할 수 있도록 하는 제어문이다.**
    - switch문에서 사용하는 키워드는 switch, case, default, break이다.
    
    ```java
    switch(변수){
      case 값1 : 
          실행문; 
          break;
      case 값2 : 
          실행문; 
          break;  
      default;    
    }
    ```
    
    - switch 문은 다음과 같은 구조를 가진다. 사용 키워드는 `switch`, `case`, `default`, `break`
    - JDK 7버전 이전에는 case 값 안에 정수 타입만 들어올 수 있었지만 지금은 문자열 타입의 변수도 올 수 있다.
    
    ### 문제1
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2029.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2030.png)
    
    ### 문제2
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2031.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2032.png)
    
- while문
    - **반복문은 실행문을 반복적으로 실행 해야 할 때 사용 한다.**
    - **반복문의 종류에는 `while문`, `do~while문`, `for문`**
    
    ### while문
    
    - 조건문의 실행 결과가 true일 때 동안 반복해서 실행한다. (false가 나올 때 까지)
    
    ```java
    // 10번 반복하면서 1~10까지 출력하는 반복문
    
    int i = 0;  //while에서 사용할 변수를 선언
    
        while(i < 10){
            System.out.println(i + 1);
            i++; //조건문을 원하는 만큼만 반복하고 빠져나가기 위한 부분 
        }
    ```
    
    ### 문제1
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2033.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2034.png)
    
    ### 문제2
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2035.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2036.png)
    
- do~while문
    - while문의 경우 조건이 만족되지 않으면 한번도 반복하지 않을 수 있다. 하지만 do while문은 **무조건 한번은 실행 되는 반복문**이다.
    
    ```java
    do{
      실행문;
    }while(조건문);
    ```
    
- for문
    - for문은 변수 초기화, 조건식, 증감식이 한 줄에 다 있는 구조이다.
        1. 초기화 식은 최초 한 번만 수행 한다.
        2. 조건식을 수행 하여 수행 결과가 false라면 for 반복문을 빠져 나간다.
        3. 수행 결과가 true라면 실행문을 수행한다.
        4. 증감식을 수행한다.
        5. 2번부터 4번까지 반복적으로 수행한다.
    
    ```java
    //for문으로 1~100까지 합을 구하는 프로그램
    
    int total = 0; //1부터 100까지 합한 결과값을 담기위한 변수 선언 
    
    for(int i = 1; i <= 100; i++){ //1부터 100까지 반복하기 위한 for 반복문 
    
        total = total + i; // 1부터 100까지 반복해서 total 변수에 값을 누적  
    }
    System.out.println(total);  //결과값 출력
    ```
    
    ### 문제
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2037.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2038.png)
    

### 4. 배열

- 1차원 배열
    - **변수가 많아져서** 하나하나 선언하기 힘들 때 **배열을 사용**한다.
    - **배열이란?** **같은 데이터 타입을 가진 연속된 메모리 공간으로 이루어진 자료구조이다.**
    
    - 자바에서 배열을 생성하는 방법
    
    ```java
    //정수 4개를 저장 할 수 있는 배열을 생성 하는 방법
    int[] array1 = new int[4]; //Java에선 new 키워드를 사용하여 배열을 생성 한다.
    
    //배열에 값을 저장하는 방법
    array1[0] = 1;
    array1[1] = 2;
    array1[2] = 3;
    array1[3] = 4;
    
    int value = array1[2];
    //value 변수에 array1[2]의 값 즉 3을 꺼내서 담는다
    System.out.println(array1[1]); 
    //array1의 인덱싱 넘버 1의 값인 2를 출력한다.
    
    //선언과 동시에 초기화 하는 방법
    int[] array = new int[]{1,2,3,4,5}; //배열에 값을 여러개 넣을 땐 '{}'를 사용한다.
    ```
    
    - 배열 사용하는 방법 (반복문)
    
    ```java
    //배열의 길이를 알아내는 방법
    int [] iarray = new int[100];
    iarray.length //<- 배열의 길이 return
    
    //for문으로 배열에 값 넣기
    for(int i = 0; i < iarray.length; i++){ 
        iarray[i] = i + 1;  
    }
    
    //배열에 저장된 값을 모두 더해주기
    int sum = 0;
    for(int i = 0; i< iarray.length; i++){          
        sum = sum + iarray[i];
    }
    System.out.println(sum);
    ```
    
    ### 문제 1
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2039.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2040.png)
    
    ### 문제2
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2041.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2042.png)
    
    ### 문제3
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2043.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2044.png)
    
- 2차원 배열
    - **2차원 배열이란 배열안에 배열을 뜻한다.**
    - 2차원 배열 생성 방법
    
    ```java
    //정수 4개씩 담을 수 있는 배열이 3개 생성된다.
    int[][] array4 = new int[3][4];
    
    //가변 크기의 2차원 배열 생성 방법
    int[][] array5 = new int[3][];//이렇게 선언하면 3개짜리의 배열은 아직 참조하는 배열이 없다.
    
    //선언과 동시에 초기화 하는 방법
    int[][] array6 = {{1}, {2,3}, {4,5,6}};
    ```
    
    ### 문제
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2045.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2046.png)
    
- for each 반복문
    
    ```java
    int[] iarr = {10,20,30,40,50};
    
    for(int value:iarr){
        System.out.println(value);
    }
    ```
    
    - 자바 1.5 버전에 추가된 구문으로 2-1학기 중간고사 시험에 나온다
    
    ### 문제
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2047.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2048.png)
    

### 5. 클래스와 객체

- 클래스 선언
    - **객체지향 언어란? - 프로그램을 구성하느 요소는 객체이며 이것이 상호작용 하도록 프로그래밍 한다.**
    - **자바는 객체를 만들기 위해 반드시 클래스를 먼저 만들어야 한다.**
    - 클래스는 객체를 만들기 위한 일종의 틀이다.
    
    ```java
    /* 자동차 클래스 만들기 */
    public class Car{}
    ```
    
    ```java
    public class CarExam{
        public static void main(String args[]){
            Car c1 = new Car();
            Car c2 = new Car();
        }
    }
    ```
    
    - new 키워드는 new 연산자 뒤에 나오는 생성자를 이요하여 메모리에 객체를 생성하라는 명령이다.
    - 메모리에 만들어진 객체를 `인스턴스`라고 한다.
    - 객체를 참조하는 변수가 c1, c2이다.
    
    ### 문제
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2049.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2050.png)
    
- 참조타입 (레퍼런스 타입)
    - ****참조형 타입은 기본형 타입을 제외한 모든 타입입니다. 앞서 배웠던, 배열도 참조형이고, 클래스도 모두 참조 타입이다.****
    - 참조형 변수
        - String str = new String(”Hello”);
        - str 변수 앞에 기본형 타입이 아닌 String class가 있다.
        - `=` 뒤에 new 생성자가 따라온다.
        - new 키워드는 객체를 메모리에 올려준다.
    
    - 메모리에 올라간 **인스턴스를 가르키는 변수, 참조하는 변수, 레퍼런스 하는 변수**가 str이다.
    - 앞으로 배울 class는 모두 참조형이다.
- String class
    - **문자열을 표현하는 자바에서 가장 많이 사용하는 클래스**
    - 자바 인스턴스 생성 방법
        
        
        1. new연산자를 이용하지 않고 인스턴스를 만드는 경우
        
        ```java
        String str1 = "hello";
        String str2 = "hello";
        ```
        
        - 다음과 같이 인스턴스를 만드는 경우 str1에서 먼저 생성된 “hello”라는 문자 상수를 str 2도 참조하게 된다.
        1. new 연산자를 사용하여 인스턴스를 만드는 경우
        
        ```java
        String str3 = new String("hello");
        String str4 = new String("hello");
        ```
        
        - new 연산자를 사용하여 인스턴스를 만들면 인스턴스는 무조건 새롭게 만들어 진다. str1, 2처럼 서로 hello 라는 값을 참조 하지 않게 된다.
        
        ```java
        if(str1 == str2){  // 같은 인스턴스를 참조하므로 결과는 true 
            System.out.println("str1과 str2는 같은 레퍼런스입니다.");
        }
        
        if(str1 == str3){  // str1과 str3은 서로 다른 인스턴스를 참조하므로 결과는 false 
            System.out.println("str1과 str3는 같은 레퍼런스입니다.");
        }
        
        if(str3 == str4){  // str3과 str4는 서로 다른 인스턴스를 참조하므로 결과는 false 
            System.out.println("str3과 str4는 같은 레퍼런스입니다.");
        }
        ```
        
        - 참조 변수끼리 ==로 비교하면 서로 같은 것을 참조하는지 아닌지 알 수 있다.
        - 그냥 문자의 값이 같은지 확인 하려면 `equals` 메서드를 사용하면 된다.
        
    
    ### 문제1
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2051.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2052.png)
    
    ### 문제2
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2053.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2054.png)
    
- class field
    - 자동차는 번호, 이름을 가지고 있고 달리고 멈추는 기능을 가지고 있다. 이런 것들을 속성이라고 하는데, 자바에서는 이런 속성을 **필드(field)**라고 부른다,
    
    ```java
    public class Car{
        String name;    
        int number;
    }
    
    public static void main(String args[]){
    	Car c1 = new Car();
      Car c2 = new Car();
    	//Car라는 인스턴스가 메모리에 2개 만들어 진다. 객체 별로 name과 number를 가진다.
    	c1.name = "소방차";
    	c1.number = 1234;
    	System.out.println(c1.name);
    }
    ```
    
    ### 문제
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2055.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2056.png)
    
- class method
    - **메소드란? - 필드가 물체의 상태라면, 물체의 행동에 해당하는 것이 메소드이다. car에 이름과 번호가 있기도 하지만, car는 앞으로 전진 할 수도 있고, 후진 하는 행동을 할 수도 있다.**
    - 메소드는 입력 값이 되고, 그 입력 값을 받아서 뭔가 한 다음 결과를 도출 해 내는 수학의 함수와 비슷한 개념이라고 한다.
    - 인자(Argument)는 어떤 함수를 호출시에 전달 되는 값을 의미한다.
    - 매개변수(Parameter)는 전달된 인자를 받아들이는 변수를 의미한다.
    
    - 따라서 메소드는 클래스가 가지고 있는 기능으로 클래스 안에서만 선언된다.
    
    - 다양한 형태의 메소드(method) 선언
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2057.png)
    
    ```java
    public class MyClass{
    		//리턴 하는 값도 없고, 매개변수도 없는 형태의 메소드
        public void method1(){
            System.out.println("method1이 실행됩니다.");
        }
    		
    		//정수로 받는 매개변수는 있으나, 리턴 하는 값이 없는 메소드
    		public void method2(int x){
            System.out.println(x + " 를 이용하는 method2입니다.");
        }
    
    		//매개 변수는 있으나 리턴 타입이 없는 메소드
    		public int method3(){
            System.out.println("method3이 실행됩니다.");
            return 10;
        }
    }
    ```
    
    - 매개 변수의 개수는 여러 개가 될 수 있다.
    
    ### 메소드 사용해보기
    
    - Myclass
    
    ```java
    public class MyClass{
      public void method(){
          System.out.println("method1이 실행됩니다.");
      }
    
      public void method2(int x){
          System.out.println(x + " 를 이용하는 method2입니다.");
      }
    
      public int method3(){
          System.out.println("method3이 실행됩니다.");
          return 10;
      }
    
      public void method4(int x, int y){
          System.out.println(x + "," + y + " 를 이용하는 method4입니다.");
      }
    
      public int method5(int y){
          System.out.println(y + " 를 이용하는 method5입니다.");
          return 5;
      }
    }
    ```
    
    - main class
    - 메소드를 사용하기 위해선 Myclass 클래스가 생성되어야 한다.
    - 객체를 생성 할 땐 new 연산자를 이용한다.
    - 메소드를 사용 할 땐 생성된 클래스를 참조하는 레퍼런스 변수, 메소드명으로 사용 할 수 있다.
    
    ```java
    public class MyClassExam{
        public static void main(String args[]){
            MyClass my1 = new MyClass(); //메소드가 정의된 클래스 생성 
    
            my1.method1();   //MyClass에서 정의해 놓은 메소드 method1() 를 호출한다.       
    
            my1.method2(10);
    
            int x = my1.method3();
    
            System.out.println("method3 이 리턴한 " + x + " 입니다.");
    
            my1.method4(10,100);
    
            int x2 = my1.method5(50);
    
            System.out.println("method5 가 리턴한 " + x2 + " 입니다.");
    
        }
    }
    ```
    
    ### 문제1
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2058.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2059.png)
    
    ### 문제2
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2060.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2061.png)
    
    ### 문제3
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2062.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2063.png)
    
- String 클래스 메소드
    - String 클래스 안에 다양한 메소드들이 존재합니다. 그 중 length(), concat, subString을 사용해봅시다.
    
    - str.length()
        - 배열의 크기를 구할 때 사용 했던 length는 괄호가 붙지 않지만, String 클래스에서의 length는 str이 참조하는 문자열의 길이를 구해 int 타입으로 리턴 해주는 메소드이다.
        
        ```java
        System.out.println(str.length());  //str
        ```
        
    - str.concat()
        - 두개의 문자열을 하나로 합쳐 하나의 String 타입으로 리턴하는 메소드이다.
        
        ```java
        String str = new String("hello");
        
        System.out.println(str.concat(" world"));  //출력결과는 hello world 
        System.out.println(str);  //출력결과는 hello
        ```
        
    - str.subString()
        - str이 참조하느 문자열의 인덱스 번호 만큼 자르는 메서드이다.
        
        ```java
        System.out.println(str.substring(1, 3)); //출력결과  el
        System.out.println(str.substring(2));   //출력결과 llo world
        ```
        
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2064.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2065.png)
    
- 변수의 scope와 static
    - **프로그램 상에서 사용되는 변수들은 사용 가능 한 범위를 가진다. 그 범위를 `변수의 scope`라고 한다.**
    - **변수가 선언된 블럭이 그 변수의 사용 범위이다.** (블럭은 중괄호 `{}`)
    
    ```jsx
    public class ValableScopeExam{
    
            int globalScope = 10;   // 인스턴스 변수 
    
            public void scopeTest(int value){   
                int localScope = 10;
                System.out.println(globalScope);
                System.out.println(localScpe);
                System.out.println(value);
            }
        }
    ```
    
    - 다음 globalScope의 사용 범위는 클래스 전체이다.
    
    - static
        - main 메소드는 static이라는 키워드로 메소드가 정의되어 있다. 이런 메서드를 static 한 메서드라고 한다.
        - static한 필드나, static한 메서드는 class가 인스턴스화 되지 않아도 사용 할 수 있다.
        - static하게 선언된 변수는 값을 저장할 수 있는 공간이 하나만 생성 된다. 그러므로, 인스턴스가 여러개 생성 되어도 static한 변수는 하나다.
        - golbalScope같은 변수(필드)는 인스턴스가 생성될때 생성되기때문에 인스턴스 변수라고 한다.
        - staticVal같은 static한 필드를 클래스 변수라고 한다.
        - 클래스 변수는 레퍼런스.변수명 하고 사용하기 보다는 클래스명.변수명 으로 사용하는것이 더 바람직하다고 하다.
            - VariableScopeExam.staticVal
            
    
    ### 문제1
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2066.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2067.png)
    
    ### 문제2
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2068.png)
    
    - wheelCount는 static으로 선언 되어 있기 때문에 하나의 값만 할당 가능하므로, 두개의 값 모두 4가 나오게 될 것이다.
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2069.png)
    
- 열거형(enum)
    - **자바에서는 열거타입을 이용하여 변수를 선언할 때 변수 타입으로 사용 할 수 있다.**
    
    ```jsx
    public class EnumExam {
        public static final String MALE = "MALE";
        public static final String FEMALE = "FEMALE";
    
        public static void main(String[] args) {
            String gender1;
    
            gender1 = EnumExam.MALE;
            gender1 = EnumExam.FEMALE;                  
        }
    }
    ```
    
    - 다음 코드에서 상수를 사용 했을 때의 문제점
        - 실행할 때 원했던 값인 MALE,FEMALE 이 아닌 다른 값이 들어오게 되므로 **문제를 발생 시킬 수 있다.**
    
    - 특정한 값만 가져야 한다면 열거형을 사용해 보자.
    
    ```jsx
    enum Gender{
        MALE, FEMALE;
    }
    
    Gender gender2;
    
    gender2 = Gender.MALE;
    gender2 = Gender.FEMALE;
    ```
    
    - **즉 관련이 있는 상수의 집합이 enum이며, enum이 나오면서 상수 사용법 또한 바뀌게 되었음**
    

### 6. 클래스 다듬기

- 생성자
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2070.png)
    
    - **모든 클래스는 인스턴스화**(클래스로부터 객체를 만들 때) **될 때 생성자를 사용합니다.**
    
    - **생성자의 특징**
        - 생성자는 return 타입이 없다. (작성 자체를 금지)
        - 생성자를 프로그래머가 만들지 않으면 **매개변수가 없는 생성자가 자동으로 생성된다**.
        - 매개변수가 없는 생성자를 **기본생성자**라고 한다.
        - 생성자를 하나라도 프로그래머가 만들었다면 기본 생성자는 자동으로 생성되지 않는다.
        
    - 생성자의 역할
    
    ```jsx
    public class Car{
        String name;
        int number;
    
        public Car(String n){
            name = n;
        }
    }
    // 인스턴스화 될 때 필드(변수)를 초기화 하는 역할을 합니다.
    ```
    
    ### 문제
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2071.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2072.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2073.png)
    
- this
    - **this는 현재 객체, 자신을 나타낸다.**
    
    ```jsx
    public class Car{
        String name;
        int number;
    
        public Car(String name){
            this.name = name;
        }
    }
    ```
    
    - 매개변수 이름과 필드 이름이 같을 때 this 키워드를 사용하여야 한다.
    - [this.name](http://this.name) = name 같이 사용하지 않고, name = name 처럼 사용할 경우, 어떤 값이 필드고, 어떤 값이 매개변수인지 알 수 없기 때문에 this keyword를 사용하여 해결해주어야 합니다.
    - **클래스 안에서 자기 자신이 가지고 있는 메소드를 사용 할 때도 this.메소드명()으로 호출 할 수있다.**
    
    ### 문제
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2074.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2075.png)
    
- method overloading
    - **메소드 오버로딩이란? - 매개변수의 유형과 개수가 다르게 하여 같은 이름의 메소드를 여러개 가질 수 있게 하는 기술**
    
    ```java
    class MyClass2{
        public int plus(int x, int y){ // 매개변수 2개 정수형 리턴
            return x+y;
        }
    
        public int plus(int x, int y, int z){ // 매개변수 3개 정수형 리턴
            return x + y + z;
        }
    
        public String plus(String x, String y){ // 매개면수 2개 문자열 리턴
            return x + y;
        }
    }
    ```
    
    ### 자기 생성자를 호출하는 this()
    
    - 객체 자신을 나타내는 this. 키워드와 다르게 자기 생성자를 호출하는 애가 된다.
    
    ```java
    public class Car{
      String name;
      int number;
    
      public Car(){
        this.name = "이름없음";
        this.number = 0;
    	}
    
      public Car(String name){
          this.name = name;
      }
    
      public Car(String name, int number){
          this.name = name;
          this.number = number;
      }
    }
    
    ```
    
    - 다음과 같은 코드에서 기본 생성자를 저렇게 사용하면 오류가 발생합니다. String name과 int number을 매개변수로 가진 생성자가 있음에도 불구하고 중복으로 사용되었기 때문입니다. 이럴 때 this()를 사용 해주면 됩니다.
    
    ```java
    public Car(){
        this("이름없음", 0);
    }//this()는 자신의 생성자를 호출 하는 것이다. 비슷한 코드가 나오는 걸 방지하기 위해 존재한다.
    ```
    
    ### 문제1
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2076.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2077.png)
    
    ### 문제2
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2078.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2079.png)
    
- 패키지
    - **패키지란 서로 관련있는 클래스 또는 인터페이스들을 묶어놓은 묶음이다. 패키지를 사용함으로써 클래스들이 필요할 때만 사용될 수 있도록 하고, 클래스를 패키지 이름과 함께 계층적인 형태로 사용함으로써 다른 그룹에 속한 클래스와 발생할 수 있는 클래스 이름간의 충돌을 막아줌으로 클래스의 관리를 편하게 해준다.**

### 7. 상속

- 상속이란
    - **상속이란? - 부모가 가진 것을 자식에게 물려주는 것을 의미합니다.**
    
    ```java
    public class Car{
    
    }
    
    public class Bus extends Car{
    
    }
    ```
    
    - Bus 클래스에서 Car 클래스를 상속 받을 때 `extends`라는 키워드를 통해 부모 클래스가 가지고 있는 것을 상속 받을 수 있다.
    
    ### 부모 클래스에 메소드 추가하기
    
    ```java
    //Car class
    public class Car{
        public void run(){
            System.out.println("달리다.");
        }
    }
    ```
    
    ```java
    //main
    public class BusExam{
        public static void main(String args[]){
            Bus bus = new Bus();
            bus.run();  
            //Bus class 는 아무런 코드를 가지지 않는다. 그럼에도 run 이라는 메소드를 사용하는데 문제가 발생되지 않는다. 
        }   
    }
    ```
    
    ```java
    //Bus class extends Car
    public class Bus extends Car{
        public void ppangppang(){
            System.out.println("빵빵");
        }       
    }
    ```
    
    - 다음과 같이 작성 하면, Bus 클래스는 Car에게 물려 받은 `run()` 메소드와 `ppangppang()` 메소드를 사용 할 수 있게 된다.
    
    ### 문제
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2080.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2081.png)
    
- 접근 제한자
    - **접근 제한자란? - 클래스 내에서 멤버의 접근을 제한하는 역할을 한다.**
    
    - 접근 제한자 종류
        - public - 어떤 클래스든 접근 할 수 있다는 것을 의미한다.
        - protected - 자기 자신, 같은 패키지, 서로 다른 패키지다 하더라도 상속 받은 자식 클래스에서는 접근 할 수 있다는 것을 의미한다.
        - private - 자기 자신만 접근할 수 있다는 것을 의미한다.
        - default - 접근 제한자를 적지 않으면 자동으로 default 접근 지정자로 되며, 자기 자신과 같은 패키지에서만 접근이 가능하다.
    
    ### 문제1
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2082.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2083.png)
    
    ### 문제2
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2084.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2085.png)
    
- 추상 클래스
    - **추상 클래스란? - 구체적이지 않은 클래스를 의미한다. 독수리, 타조는 구체적인 새를 지칭하지만, 새, 포유류 같은 것들은 구체적이지 않다. 이런 것을 구현한 클래스를 추상 클래스라고 한다.**
    
    - 추상클래스는 **abstract** 키워드를 이용하여 정의한다.
    - 추상 클래스는 미완성의 추상 메소드를 포함 할 수 있다. 미완성의 추상 메소드란? 구현이 되지 않은 메소드를 뜻한다.
        
        
        ```java
        public abstract class Bird{
            public abstract void sing();
        
            public void fly(){
                System.out.println("날다.");
            }
        }
        ```
        
        - 다음과 같이 추상 클래스와 추상 메서드를 선언 한 후 추상 클래스를 상속 받는 Duck 클래스를 살펴보자
        
        ```java
        public class Duck extends Bird{
            @Override
            public void sing() {
                System.out.println("꽥꽥!!");
            }
        }
        ```
        
        - 추상 클래스를 상속 받은 클래스는 추상 클래스가 가지고 있는 추상 메소드를 반드시 구현해야 한다.
        - 따라서 상속할 때 추상적인 메소드를 추가 하려면 추상 클래스를 선언 해주면 된다.
        
        ### 문제
        
        ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2086.png)
        
        ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2087.png)
        
- super와 부모생성자
    - **클래스가 인스턴스화 될 때 생성자가 실행 되면서 객체의 초기화를 한다. 그 때 자신의 생성자만 실행이 되는 것이 아니고, 부모의 생성자부터 실행된다.**
    
    ```java
    public class Car{
        public Car(){
            System.out.println("Car의 기본생성자입니다.");
        }
    }
    
    public class Bus extends Car{
        public Bus(){
            System.out.println("Bus의 기본생성자입니다.");
        }
    }
    
    public class BusExam{
          public static void main(String args[]){
              Bus b = new Bus();
          }
    }
    ```
    
    - new 키워드로 Bus객체를 생성하면, Bus 객체가 메모리에 올라갈 때 부모인 Car도 함께 메모리에 올라가기 때문에 다음 코드는 이런 실행 결과를 나타낸다.
    
    ```java
    //Car의 기본생성자입니다.
    //Bus의 기본생성자입니다.
    ```
    
    - 객체 자신을 가르키는 키워드가 `this`였다면, 부모를 가르키는 키워드는 `super`이다.
    - `super()`는 부모의 생성자를 의미한다.
    
    ```java
    public class Car{
        public Car(String name){
            System.out.println(name + " 을 받아들이는 생성자입니다.");
        }
    }
    ```
    
    - Car 클래스 코드를 다음과 같이 수정 하면, Bus 생성자에서 컴파일 오류가 발생한다.
    - 기본 생성자가 없어지고 다른 생성자에 String 매개변수가 생겼기 때문이다.
    - 이럴 땐 `this()`를 사용 했던 것 처럼 `super()`를 사용 해주면 된다.
    
    ```java
    public Bus(){
        super("소방차"); // 문자열을 매개변수로 받는 부모 생성자를 호출하였다.
        System.out.println("Bus의 기본생성자입니다.");
    }
    ```
    
    ### 문제
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2088.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2089.png)
    
- 오버라이딩
    - **오버라이딩이란? - 부모가 가지고 있는 메소드와 똑같은 모양의 메소드를 자식이 가지고 있는 것이다. 즉 오버라이딩이란 메소드를 재정의 하는 것이다.**
    
    ```java
    //run 메소드를 가지고 있는  Car클래스 
    public class Car{
        public void run(){
            System.out.println("Car의 run메소드");
        }
    }
    
    //Car 를 상속받는 Bus 클래스 
    public class Bus extends Car{
    		public void run(){
    	      System.out.println("Bus의 run메소드");
    	  }
    }
    
    public class BusExam{
        public static void main(String args[]){
            Bus bus = new Bus();
            bus.run();  //Car의 run메소드가 실행 되는 것이 아닌 오버라이딩 된 Bus클래스의 run이 실행 된다.
        }
    }
    ```
    
    - 메소드를 오버라이딩 하면, **항상 자식클래스에서 정의된 메소드가 호출된다.**
    - 오버라이딩 한다고 해서 부모의 메소드가 사라지는 것은 아니다.
    
    ```java
    public class Bus extends Car{
        public void run(){
            super.run();  // 부모의  run()메소드를 호출 
            System.out.println("Bus의 run메소드");
        }
    }
    ```
    
    - `super`키워드를 통해 부모의 메소드도 호출이 가능 하다.
    
    ### 문제 1
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2090.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2091.png)
    
    ### 문제2
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2092.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2093.png)
    
- 클래스 형변환
    - **부모타입으로 자식 객체를 참조하게 되면 부모가 가지고 있는 메소드만 사용할수 있다. 따라서 자식 객체가 가지고 있는 메소드나 속성을 사용하려면 형변환 해야 한다.**
    
    ```java
    public class Car{
        public void run(){
            System.out.println("Car의 run메소드");
        }
    }
    
    public class Bus extends Car{
        public void ppangppang(){
            System.out.println("빵빵.");
        }   
    }
    
    public class BusExam{
        public static void main(String args[]){
            Car car = new Bus();
            car.run();
            car.ppangppang(); // 컴파일 오류 발생
        }
    }
    ```
    
    - 메인 클래스를 보면 `Car car = new Bus();`를 확인 해보면, Car은 부모타입인데 부모타입에서 자식인 Bus의 메소드인 ppangppang()을 사용하려고 하니 컴파일 오류가 발생 할 수 밖에 없다.
    - 따라서 부모타입인 car를 Bus로 바꿔 사용해주면 된다.
    
    ```java
    public class BusExam{
        public static void main(String args[]){
            Car car = new Bus();
            car.run();
            //car.ppangppang(); // 컴파일 오류 발생
    
            Bus bus = (Bus)car;  //부모타입을 자식타입으로 형변환 
            bus.run();
            bus.ppangppang();
        }
    }
    ```
    
    ### 문제 1
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2094.png)
    
    ### 문제 2
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2095.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2096.png)
    

### 8. 인터페이스와 다른 형식의 클래스

- 인터페이스
    - **인터페이스란? - 서로 관계가 없는 물체들이 상호 작용을 하기 위해 사용하는 장치나 시스템을 뜻한다.**
    - 인터페이스에서는 추상 메소드와 상수를 정의할 수 있다.
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2097.png)
    
    ```java
    public interface TV{
        public int MAX_VOLUME = 100;
        public int MIN_VOLUME = 0;
    
        public void turnOn();
        public void turnOff();
        public void changeVolume(int volume);
        public void changeChannel(int channel);
    }
    ```
    
    - 인터페이스에서는 추상 메서드와 상수를 정의 할 수 있다.
    - 다음과 같이 선언 한다면 컴파일 시 자동으로 아래와 같이 바귄다.
    
    ```java
    public static final int MAX_VOLUME = 100;
    public static final int MIN_VOLUME = 0;
    public abstract void on();
    public abstract void off();
    public abstract void volume(int value);
    public abstract void channel(int number);
    ```
    
    - 인터페이스를 사용 할 땐 클래스에서 `implements` 키워드를 사용한다.
    
    ```java
    public class LedTV implements TV{
        public void on(){
            System.out.println("켜다");
        }
        public void off(){
            System.out.println("끄다");   
        }
        public void volume(int value){
            System.out.println(value + "로 볼륨조정하다.");  
        }
        public void channel(int number){
            System.out.println(number + "로 채널조정하다.");         
        }
    }
    ```
    
    - 인터페이스가 가지고 있는 메소드를 하나라도 구현하지 않으면, 해당 클래스는 추상 클래스가 된다.(추상 클래스는 인스턴스를 만들 수 없다.)
    
    ```java
    public class LedTVExam{
        public static void main(String args[]){
            TV tv = new LedTV();
            tv.on();
            tv.volume(50);
            tv.channel(6);
            tv.off();
        }
    }
    ```
    
    - 참조변수의 타입으로 인터페이스를 사용 할 수 있다. 이러한 경우엔 인터페이스가 가지고 있는 메소드만 사용 할 수 있다.
    - TV 인터페이스를 구현하는 LCDTV를 만들었다면 위의 코드에서 new LedTV를 LcdTV로만 바꿔도 똑같이 프로그램이 작동할 것입니다. 동일한 인터페이스를 구현한다는 것은 클래스 사용법이 같다는 것을 뜻합니다.
    
    ### 문제 1
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2098.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%2099.png)
    
    ### 문제 2
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%20100.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%20101.png)
    
- 인터페이스의 default method
    - 인터페이스가 default 키워드로 선언되면 메소드가 구현될 수 있다. 또한 이를 구현하는 클래스는 default 메소드를 오버라이딩 할 수 있다.
    
    ### default 메소드
    
    ```java
    public interface Calculator {
        public int plus(int i, int j);
        public int multiple(int i, int j);
        default int exec(int i, int j){      //default로 선언함으로 메소드를 구현할 수 있다.
            return i + j;
        }
    }
    ```
    
    ### static 메소드
    
    ```java
    public interface Calculator {
        public int plus(int i, int j);
        public int multiple(int i, int j);
        default int exec(int i, int j){
            return i + j;
        }
        public static int exec2(int i, int j){   //static 메소드 
            return i * j;
        }
    }
    
    public class MyCalculatorExam {
        public static void main(String[] args){
            Calculator cal = new MyCalculator();
            int value = cal.exec(5, 10);
            System.out.println(value);
    
            int value2 = Calculator.exec2(5, 10);  //static메소드 호출 
            System.out.println(value2);
        }
    }
    ```
    
    - 인터페이스에 static 메소드를 선언 하면, 인터페이스를 이용하여 간단한 기능을 가지는 유틸리티성 인터페이스를 만들 수 있다.
    
    ### 문제
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%20102.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%20103.png)
    
- 내부 클래스
    - **내부 클래스란? - 클래스 안에 선언된 클래스**
    - 어떤 위치에 선언하느냐에 따라 4가지 형태가 있을 수 있다.
        - 첫번째는 클래스 안에 인스턴스 변수, 즉 필드를 선언하는 위치에 선언 된 경우는 **중첩 클래스**라고 부른다.
        
        ```java
        public class InnerExam1{
            class Cal{ //중첩 클래스
                int value = 0;
                public void plus(){
                    value++;
                }
            }
        
            public static void main(String args[]){
                InnerExam1 t = new InnerExam1();
                InnerExam1.Cal cal = t.new Cal();
                cal.plus();
                System.out.println(cal.value);
        
            }
        }
        ```
        
        - 두번째는 내부 클래스가 static으로 정의 된 경우 **정적 중첩 클래스** 또는 static 클래스라고 부른다.
        
        ```java
        public class InnerExam2{
            static class Cal{ //정적 중첩 클래스
                int value = 0;
                public void plus(){
                    value++;
                }
            }
        
            public static void main(String args[]){
                InnerExam2.Cal cal = new InnerExam2.Cal();
                cal.plus();
                System.out.println(cal.value);
        
            }
        }
        ```
        
        - 세번째로는 메소드 안에 클래스를 선언한 경우, **지역 중첩 클래스** 또는 지역 클래스라고 한다.
        
        ```java
        public class InnerExam3{
            public void exec(){
                class Cal{ //지역 중첩 클래스
                    int value = 0;
                    public void plus(){
                        value++;
                    }
                }
                Cal cal = new Cal();
                cal.plus();
                System.out.println(cal.value);
            }
        
            public static void main(String args[]){
                InnerExam3 t = new InnerExam3();
                t.exec();
            }
        }
        ```
        
        - 네번째로는 익명 중첩 클래스 또는 **익명 클래스**라고 부르는 클래스이다.
        
        ```java
        //추상클래스 Action 
        public abstract class Action{
            public abstract void exec();
        }
        
        //추상클래스 Action을 상속받은 클래스 MyAction
        
        public class MyAction extends Action{
            public void exec(){
                System.out.println("exec");
            }
        }
        
        //MyAction을 사용하는 클래스 ActionExam 
        public class ActionExam{
            public static void main(String args[]){
                Action action = new MyAction();
                action.exec();
            }
        }
        
        //MyAction을 사용하지 않고 Action을 상속받는 익명 클래스를 만들어서 사용하도록 수정해 보도록 하겠습니다.
        public class ActionExam{
            public static void main(String args[]){
                Action action = new Action(){
                    public void exec(){
                        System.out.println("exec");
                    }
                };
                action.exec();
            }
        }
        ```
        
        - 생성자 다음에 중괄호 열고 닫고가 나오면, 해당 생성자 이름에 해당하는 클래스를 상속받는 이름없는 객체를 만든다는 것을 뜻한다.
        

### 9. 예외 처리

- Exepction
    - **프로그램 실행중 예기치 못한 사건을 예외라고 한다. 예외 상황을 미리 예측하고 처리할 수 있는데, 이렇게 하는 것을 예외 처리라고 한다.**
    
    ```java
    public class ExceptionExam {
        public static void main(String[] args) {
            int i = 10;
            int j = 0;
            try{
                int k = i / j; //0으로 나눠서 오류 발생
                System.out.println(k);
            }catch(ArithmeticException e){
                System.out.println("0으로 나눌 수 없습니다. : " + e.toString());
            }finally {
                System.out.println("오류가 발생하든 안하든 무조건 실행되는 블록입니다.");
            }
        }
    }
    ```
    
    - 자바에선 정수를 정수로 나눌 때 0으로 나누면 안된다. 0으로 나누면 오류가 발생 한다.
    - 자바에서 예외처리를 하기 위해 `try`라는 블록으로 감싼 후 오류와 관련 된 `Exception`을 catch 블록에서 처리한다.
    
    - 위 코드같이 `try` 블럭엔 오류가 생길 만한 구문을 작성, `exception` 블럭은 try 블럭에서 오류가 발생 하였을 때 사용하고, finally 블럭은 오류가 발생 하든, 안 하든 무조건 실행 되는 블록이다.
    
    ### 문제
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%20104.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%20105.png)
    
- Throws
    - **Throws란? - 예외가 발생 했을 때 예외를 호출한 쪽에서 처리하도록 던져준다.**
    
    ```java
    public class ExceptionExam2 {   
        public static void main(String[] args) {
            int i = 10;
            int j = 0;
            int k = divide(i, j);
            System.out.println(k);
        }
    
        public static int divide(int i, int j){
            int k = i / j;
            return k;
        }
    }
    ```
    
    - 정수를 나눠주는 divide 메소드를 main 메소드에서 호출 한다.  하지만 다음은 정수를 0으로 나누는 코드이기에 오류가 발생 한다. 이럴 때 메소드 뒤에 exception을 선언해 줄 수 있다.
    
    ```java
    public class ExceptionExam2 {
    
        public static void main(String[] args) {
            int i = 10;
            int j = 0;
            int k = divide(i, j);
            System.out.println(k);
        }
    
        public static int divide(int i, int j) throws ArithmeticException{
            int k = i / j;
            return k;
        }
    }
    ```
    
    ### 문제
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%20106.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%20107.png)
    
    - IllegalArgumentException
    
    ```java
    public class ExceptionExam3 {   
        public static void main(String[] args) {
            int i = 10;
            int j = 0;
            try{
                int k = divide(i, j);
                System.out.println(k);
            }catch(IllegalArgumentException e){
                System.out.println("0으로 나누면 안됩니다.");
            }           
        }
    
        public static int divide(int i, int j) throws IllegalArgumentException{
            if(j == 0){
                throw new IllegalArgumentException("0으로 나눌 수 없어요.");
            }
            int k = i / j;
            return k;
        }   
    }
    ```
    
    - `IllegalArgumentException`를 사용하면, divide를 호출한 쪽에서 처리를 해야한다는 것을 의미한다.
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%20108.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%20109.png)
    
- 사용자 정의 Exception
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%20110.png)
    
    - Exception을 상속 받은 클래스를 Checked Exception이라고 한다.
    - Runtime Exception을 상속 받은 클래스는 Unchecked Exception이라고 한다.
    
    ### 문제 1
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%20111.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%20112.png)
    
    ### 문제 2
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%20113.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%20114.png)
    

### 10. 끝 (약수의 합)

- 약수의 합
    
    ### 문제
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%20115.png)
    
    ![Untitled](%5B11%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%5D%20Java%2072d1f6ba29a54f048f33663e001f93cf/Untitled%20116.png)