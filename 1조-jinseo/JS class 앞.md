# 클래스

> 클래스는 객체 지향 프로그래밍에서 특정 객체를 생성하기 위해 변수와 메소드를 정의하는 일종의 틀로, 객체를 정의하기 위한 상태(멤버 변수)와 메서드(함수)로 구성된다.
> 

## 기본 문법

```jsx
class MyClass {
  // 여러 메서드를 정의할 수 있음
  constructor() { ... }
  method1() { ... }
  method2() { ... }
  method3() { ... }
  ...
}
```

# 클래스란

> 자바스크립트에서 클래스는 함수의 한 종류입니다.
> 

```jsx
class User {
  constructor(name) { this.name = name; }
  sayHi() { alert(this.name); }
}

// User가 함수라는 증거
alert(typeof User); // function
```

1. User 라는 이름을 가진 함수를 만듭니다. 함수 본문은 생성자 메서드 constructor에서 가져옵니다. 생성자 매서드가 없으면 본문이 비워진 채로 함수가 만들어집니다.
2. sayHi 같은 클래스 내에서 정의한 매서드를 User.prototype에 저장합니다.

## 클래스는 단순한 편의 문법이 아니다.

> 참고로 기능은 동이라하나 기존 문법을 쉽게 읽을 수 있게 만든 문법을 편의문법이라고 합니다.
> 

```jsx
// class User와 동일한 기능을 하는 순수 함수를 만들어보겠습니다.

// 1. 생성자 함수를 만듭니다.
function User(name) {
  this.name = name;
}
// 모든 함수의 프로토타입은 'constructor' 프로퍼티를 기본으로 갖고 있기 때문에
// constructor 프로퍼티를 명시적으로 만들 필요가 없습니다.

// 2. prototype에 메서드를 추가합니다.
User.prototype.sayHi = function() {
  alert(this.name);
};

// 사용법:
let user = new User("John");
user.sayHi();
```

- 위 예시처럼 순수 함수로 클래스 역할을 하는 함수를 선언하는 방법과 class 키워드를 사용하는 방법의 결과는 거의 같습니다.
1. class로 만든 함수엔 특수 내부 프로퍼티인 [[IsClassConstructor]] : true가 이름표처럼 붙습니다.
    1. 클래스 생성자를 new와 함께 호출하지 않으면 에러가 발생하는데 이때 위에 있는 프로퍼티를 사용
2. 클래스에 정의도니 메서드를 열거할 수 없습니다. 클래스의 protoype 프로퍼티에 추가된 메서드의 enumerable(열거) 플래그는 false입니다.
    1. for..in 으로 객체를 순회 할 때, 메서드는 순회 대상에서 제외하고자 하는 경우가 많으므로 유용

# 클래스 표현식

클래스도 다른 표현식 내부에서 정의, 전달, 반환, 할당 할 수 있습니다.

```jsx
let User = class {
  sayHi() {
    alert("안녕하세요.");
  }
};
```

- 기명 함수 표현식과 유사하게 클래스 표현식에도 이름을 붙일 수 있습니다.

<aside>
💡 클래스 표현식에 이름을 붙이면, 이 이름은 오직 클래스 내부에서만 사용 할 수 있습니다

</aside>

- 필요에 따라 클래스를 동적으로 생성하는 것도 가능

# getter와 setter

> 리터럴을 사용해 만든 객체처럼 클래스도 getter나 setter, 계산된 프로퍼티를 지원함
> 

```jsx
class User {

  constructor(name) {
    // setter를 활성화합니다.
    this.name = name;
  }

  get name() {
    return this._name;
  }

  set name(value) {
    if (value.length < 4) {
      alert("이름이 너무 짧습니다.");
      return;
    }
    this._name = value;
  }

}

let user = new User("보라");
alert(user.name); // 보라

user = new User(""); // 이름이 너무 짧습니다.
```

- getter와 setter는 User.prototype에 정의됨

## 계산된 메서드 이름 [...]

```jsx
class User {

  ['say' + 'Hi']() {
    alert("Hello");
  }

}

new User().sayHi();
```

- 계산된 메서드 이름은 리터럴 객체와 유사한 형태를 띠기 때문에 사용법을 외우기 쉽다는 장점이 있습니다.

## 클래스 필드

> 클래스 필드라는 문법을 사용하면 어떤 종류의 프로퍼티도 클래스에 추가할 수도 있습니다
> 

```jsx
class User {
  name = "보라";

  sayHi() {
    alert(`${this.name}님 안녕하세요!`);
  }
}

new User().sayHi(); // 보라님 안녕하세요!
```

- 클래스를 정의할 때 <프로퍼티 이름> = <값>을 써주면 간단히 클래스 필드를 만들 수 있음
- User.prototype이 아닌 개별 객체에서만 클래스 필드가 설정된다는 점

## 클래스 필드로 바인딩 된 메서드 만들기

<aside>
📌 자바스크립트에서 this는 동적으로 결정됨 따라서 객체 메서드를 여기저기 전달해 전혀 다른 컨텍스트에서 호출되면 this는 메서드가 정의된 객체를 참조하지 않음.

</aside>

# 클래스 상속

## extend 키워드

> class를 다른 class의 자식으로 만들기 위해 사용
> 
- `class 자식 클래스명 extends 부모클래스명 {}`

<aside>
📌 자식 클래스는  자식 클래스에 정의된 메서드에도 접근할 수 있고, 부모 클래스에 정의된 메서드에도 접근 가능

</aside>

<aside>
📌 extends 뒤에 표현식이 올 수도 있습니다.

</aside>

<aside>
📌 자바스크립트의 내장 객체는 프로토타입을 기반으로 상속 관계를 맺습니다.

</aside>

## 메서드 오버라이딩

- `super`
    - super.method(...)는 부모 클래스에 정의된 메서드, method를 호출합니다.
    - super(...)는 부모 생성자를 호출하는데, 자식 생성자 내부에서만 사용 할 수 있습니다.
    
    <aside>
    📌 화살표 함수엔 super가 없습니다.
    
    </aside>
    

## 생성자 오버라이딩

```jsx
class Rabbit extends Animal {
  // 자체 생성자가 없는 클래스를 상속받으면 자동으로 만들어짐
  constructor(...args) {
    super(...args);
  }
}
```

- 생성자는 기본적으로 부모 constructor 를 호출합니다. 이때 부모 constructor에도 인수를 모두 전달합니다. 클래스에 자체 생성자가 없는 경우엔 이런 일이 모두 자동으로 일어납니다.

<aside>
📌 상속 클래스의 생성자에선 반드시 super(...)를 호출해야하는데, super(...)를 호출하지 않으면 에러가 발생해 super(...)는 this를 사용하기 전에 반드시 호출해야 합니다.

</aside>

- 왜 super(...)를 호출해야할까?
    
    > 자바스크립트는 ‘상속 클래스의 생성자 함수와 그렇지 않은 생성자 함수를 구분합니다.
    > 
    
    > 상속 클래스의 생성자 함수엔 특수 내부 프로퍼티인 [[ConstructorKind]] : “derived”가 이름표처럼 붙습니다.
    > 
    
    > 일반 클래스의 생성자 함수와 상속 클래스의 생성자 함수 간 차이는 new와 함께 드러납니다
    > 
    - 일반 클래스가 new와 함께 실행되면, 빈 객체가 만들어지고 this에 이 객체를 할당합니다.
    - 반면, 상속 클래스의 생성자 함수가 실행되면, 일반 클래스에서 일어난 일이 일어나지 않습니다. 상속 클래스의 생성자 함수는 빈 객체를 만들고 this에 이 객체를 할당하는 일을 부모 클래스의 생성자가 처리해주길 기대합니다.
    
    <aside>
    📌 이런 차이 때문에 상속 클래스의 생성자에선 super를 호출해 부모 생성자를 실행해 주어야 합니다. 그렇지 않으면 this가 될 객체가 만들어지지 않아 에러가 발생합니다.
    
    </aside>
    

## 클래스 필드 오버라이딩

<aside>
🔥 부모 생성자는 자식 클래스에서 오버라이딩 값이 아닌, 부모 클래스 안의 필드 값을 사용한다

</aside>

- 클래스 필드 초기화 순서
    - 아무것도 상속받지 않는 베이스 클래스는 생성자 실행 이전에 초기화됨
    - 부모 클래스가 있는 경우엔 super() 실행 직후에 초기화 됨

# 정적 메서드와 정적 프로퍼티

### 정적 메서드

> “prototype”이 아닌 클래스 함수 자체에 메서드를 설정할 수도 있습니다. 이런 메서드를 정적(static)메서드라고 부릅니다.
> 
- 정적 메서드는 메서드를 프로퍼티 형태로 직접 할당하는 것과 동일한 일을 합니다.
- 정적 메서드는 어떤 특정한 객체가 아닌 클래스에 속한 함수를 구현하고자 할 때 주로 사용
- 항목 검색, 저장, 삭제 등을 수행해주는 데이터베이스 관련 클래스에도 사용

<aside>
🔥 정적메서드는 특정 클래스 인스턴스가 아닌 클래스 ‘전체'에 필요한 기능을 만들 때 사용할 수 있습니다.

</aside>

### 정적 프로퍼티

> 정적 프로퍼티는 일반 클래스 프로퍼티와 유사하게 생겼는데 앞에 static이 붙는다는 점만 다릅니다.
> 

<aside>
🔥 데이터를 클래스 수준에 저장하고 싶을 때 사용하빈다. 정적 프로퍼티 역시 개별 인스턴스에 묶이지 않습니다.

</aside>

## 정적 프로퍼티와 정적메서드는 상속이 가능